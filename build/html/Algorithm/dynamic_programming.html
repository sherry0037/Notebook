

<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Dynamic Programming &#8212; Notebook  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/yeen.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Hash" href="hash_table.html" />
    <link rel="prev" title="Disjoint Set" href="disjoint_set.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="hash_table.html" title="Hash"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="disjoint_set.html" title="Disjoint Set"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Notebook  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Dynamic Programming</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Dynamic Programming</a><ul>
<li><a class="reference internal" href="#jump-game">55. Jump Game</a></li>
<li><a class="reference internal" href="#edit-distance">72. Edit Distance</a></li>
<li><a class="reference internal" href="#distinct-subsequences">115. Distinct Subsequences</a></li>
<li><a class="reference internal" href="#binary-tree-maximum-path-sum">124. Binary Tree Maximum Path Sum</a></li>
<li><a class="reference internal" href="#dungeon-game">174. Dungeon Game</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="disjoint_set.html"
                        title="previous chapter">Disjoint Set</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="hash_table.html"
                        title="next chapter">Hash</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/Algorithm/dynamic_programming.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="dynamic-programming">
<h1><a class="toc-backref" href="#id1">Dynamic Programming</a><a class="headerlink" href="#dynamic-programming" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#dynamic-programming" id="id1">Dynamic Programming</a></p>
<ul>
<li><p><a class="reference internal" href="#jump-game" id="id2">55. Jump Game</a></p></li>
<li><p><a class="reference internal" href="#edit-distance" id="id3">72. Edit Distance</a></p></li>
<li><p><a class="reference internal" href="#distinct-subsequences" id="id4">115. Distinct Subsequences</a></p></li>
<li><p><a class="reference internal" href="#binary-tree-maximum-path-sum" id="id5">124. Binary Tree Maximum Path Sum</a></p></li>
<li><p><a class="reference internal" href="#dungeon-game" id="id6">174. Dungeon Game</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="jump-game">
<h2><a class="toc-backref" href="#id2">55. Jump Game</a><a class="headerlink" href="#jump-game" title="Permalink to this headline">¶</a></h2>
<p>You are given an integer array nums. You are initially positioned at the array’s first index, and each element in the array represents your maximum jump length at that position.</p>
<p>Return true if you can reach the last index, or false otherwise.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: nums = [2,3,1,1,4]</p>
<p>Output: true</p>
<p>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: nums = [3,2,1,0,4]</p>
<p>Output: false</p>
<p>Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</p>
</div>
<p><strong>Approach 1</strong>:</p>
<ul class="simple">
<li><p>Maintain an array of booleans where at index i, it means “can I jump from position i to the end?”.</p></li>
<li><p>Loop backwards; begin by filling in the array from the end.</p></li>
<li><p>jump[n-1] = true; (it’s always true at the end position).</p></li>
<li><p>At position i, we can jump from i+1 to i+nums[i] (or til the end, whichever is first). So we check if that position is true, if so, it means we can jump from i to that position then to the end.</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="c1">// at each position i, can I jump to the end?</span>
    <span class="c1">// jump[n-1] = true</span>
    <span class="c1">// jump[i] = j from i+1 to i + nums[i], jump[j] == true</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canJump</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">jump</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="o">]</span><span class="p">;</span>
        <span class="n">jump</span><span class="o">[</span><span class="n">nums</span><span class="p">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">boolean</span> <span class="n">canJ</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
            <span class="c1">// System.out.println(&quot;i: &quot; + i);</span>
            <span class="c1">// System.out.println(&quot;i + nums[i]: &quot; + (i + nums[i]));</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//System.out.print(&quot;j: &quot; + j + &quot; &quot;);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">jump</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">canJ</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>

            <span class="p">}</span>
            <span class="c1">// System.out.println(&quot;&quot;);</span>
            <span class="n">jump</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">canJ</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">jump</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p><strong>Approach 2</strong></p>
<ul class="simple">
<li><p>Only need to maintain one index <code class="docutils literal notranslate"><span class="pre">canJump</span></code> indicating the location from where can jump to the end.</p></li>
<li><p>Loop backwards, at current location i, if we can jump to <code class="docutils literal notranslate"><span class="pre">canJump</span></code>, then update <code class="docutils literal notranslate"><span class="pre">canJump</span></code> to the current location.</p></li>
<li><p>If at the end canJump == 0, return true.</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canJump</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">canJump</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="na">length</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">canJump</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">canJump</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">canJump</span><span class="o">==</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="edit-distance">
<h2><a class="toc-backref" href="#id3">72. Edit Distance</a><a class="headerlink" href="#edit-distance" title="Permalink to this headline">¶</a></h2>
<p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following three operations permitted on a word:</p>
<p>Insert a character</p>
<p>Delete a character</p>
<p>Replace a character</p>
<p><strong>Approach</strong>:</p>
<ul>
<li><p>Set dp[i][j] to be how many edits are needed to change word1[0][i-1] to word2[0][j-1].</p>
<blockquote>
<div><ul class="simple">
<li><p>“-1” is because row 0 and column 0 of dp are the cases when word1 or word2 is 0.</p></li>
<li><p>e.g, “horse” to “ros”. First column corresponds to “horse” to “”; first row corresponds to “” to “ros”.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>For dp[i][j], if word1[i-1] == word2[i-1], that means the new characters are the same, so no additional edits needed. So dp[i][j] = dp[i-1][j-1].</p>
<blockquote>
<div><ul class="simple">
<li><p>e.g. “xxxxxe” to “yyyyye” has the same number of edits as “xxxxx” to “xxxxx”</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Then there are three possibilities (for the following examples, i, j points to the last character of the two words):</p>
<blockquote>
<div><ul>
<li><p>Insert: dp[i][j] = dp[i][j-1] + 1</p>
<blockquote>
<div><ul class="simple">
<li><p>e.g. for “xxxxx” to “yyyyye”, edits equals to edits of “xxxxx” to “yyyyy” + 1 insertion.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Delete: dp[i][j] = dp[i-1][j] + 1</p>
<blockquote>
<div><ul class="simple">
<li><p>e.g. for “xxxxxe” to “yyyyy”, edits equals to edits of “xxxxx” to “yyyyy” + 1 deletion.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Replace: dp[i][j] = dp[i-1][j-1] + 1</p>
<blockquote>
<div><ul class="simple">
<li><p>e.g. for “xxxxxe” to “yyyyyf”, edits equals to edits of “xxxxx” to “yyyyy” + 1 replace.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>Then dp[i][j] is set to the minimum of the three cases.</p>
</div></blockquote>
</li>
<li><p>Finally returns dp[n+1][m+1].</p></li>
</ul>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: word1 = “horse”, word2 = “ros”</p>
<p>Output: 3</p>
<p>Explanation:</p>
<p>horse -&gt; rorse (replace ‘h’ with ‘r’)</p>
<p>rorse -&gt; rose (remove ‘r’)</p>
<p>rose -&gt; ros (remove ‘e’)</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: word1 = “intention”, word2 = “execution”</p>
<p>Output: 5</p>
<p>Explanation:</p>
<p>intention -&gt; inention (remove ‘t’)</p>
<p>inention -&gt; enention (replace ‘i’ with ‘e’)</p>
<p>enention -&gt; exention (replace ‘n’ with ‘x’)</p>
<p>exention -&gt; exection (replace ‘n’ with ‘c’)</p>
<p>exection -&gt; execution (insert ‘u’)</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="p">(</span><span class="n">String</span> <span class="n">word1</span><span class="p">,</span> <span class="n">String</span> <span class="n">word2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word1</span><span class="p">.</span><span class="na">length</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">word2</span><span class="p">.</span><span class="na">length</span><span class="p">();</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">rst</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>

    <span class="c1">//column 0 and row 0 means word1 or word2 are empty</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
        <span class="n">rst</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">word1</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">word2</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
                <span class="c1">//System.out.println(&quot;i: &quot;+i + &quot; j: &quot;+j + &quot; rst: &quot;+rst[i][j]);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="c1">//System.out.println(&quot;i: &quot;+i + &quot; j: &quot;+j + &quot; rst: &quot;+rst[i][j]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">rst</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">m</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="distinct-subsequences">
<h2><a class="toc-backref" href="#id4">115. Distinct Subsequences</a><a class="headerlink" href="#distinct-subsequences" title="Permalink to this headline">¶</a></h2>
<p>Given two strings s and t, return the number of distinct subsequences of s which equals t.</p>
<p>A string’s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters’ relative positions. (i.e., “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>It is guaranteed the answer fits on a 32-bit signed integer.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: s = “rabbbit”, t = “rabbit”</p>
<p>Output: 3</p>
<p>Explanation:</p>
<p>As shown below, there are 3 ways you can generate “rabbit” from S.</p>
<p><strong>rabb</strong> b <strong>it</strong></p>
<p><strong>ra</strong> b <strong>bbit</strong></p>
<p><strong>rab</strong> b <strong>bit</strong></p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: s = “babgbag”, t = “bag”</p>
<p>Output: 5</p>
<p>Explanation:</p>
<p>As shown below, there are 5 ways you can generate “bag” from S.</p>
<p><strong>ba</strong> b <strong>g</strong> bag</p>
<p><strong>ba</strong> bgba <strong>g</strong></p>
<p><strong>b</strong> abgb <strong>ag</strong></p>
<p>ba <strong>b</strong> gb <strong>ag</strong></p>
<p>babg <strong>bag</strong></p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>1 &lt;= s.length, t.length &lt;= 1000</p>
<p>s and t consist of English letters.</p>
</div>
<p><strong>Approach</strong></p>
<ul>
<li><p>rst[i][j] means the number of distinct subsequences of t[0][j] in s[0][i].</p></li>
<li><p>The first column rst[i][0] equals to the number of t[0] in s.</p>
<blockquote>
<div><ul class="simple">
<li><p>For example, s = “rabbbit”, t = “rabbit”, rst[i][0][i] is the number of r in “r”, “ra”, “rab”, … “rabbbit”.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Then we fill in column by column, from left to right.</p></li>
<li><p>rst[j][j] is special, it is if t[0][j] and s[0][j] are equal.</p></li>
<li><p>We don’t need to consider rst[i][j] where j&gt;i</p></li>
<li><p>Then for rst[i][j], compare if s[i] and t[j] are the same.</p>
<blockquote>
<div><ul>
<li><p>If they are not the same, rst[i][j] = rst[i-1][j] (copy the previous element)</p>
<blockquote>
<div><ul class="simple">
<li><p>e.g. if rst[i][j] is number of “rab” in “rabbbi**t**” and rst[i-1][j] is number of “rab” in “rabbbi”, then they are the same because “t” != “b”.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>If they are the same, rst[i][j] = rst[i-1][j-1] + rst[i-1][j]</p>
<blockquote>
<div><ul>
<li><p>e.g. Consider rst[i][j] is “rabb” in “rabbb”, then rst[i-1][j] is “rabb” in “rabb” (1) and rst[i-1][j-1] is “rab” in “rabb” (2).</p>
<blockquote>
<div><ul class="simple">
<li><p>From “rab” in “rabb”, we have “<strong>rab</strong> b” and “<strong>ra</strong> b <strong>b</strong>”. Now for rst[i][j] we can add an additional b at the end: “<strong>rab</strong>  b <strong>b</strong>” and “<strong>ra</strong> b <strong>bb</strong>”</p></li>
<li><p>From “rabb” in “rabb”, we have “<strong>rabb</strong>”. Now for rst[i][j] we again add an additional b at the end: “<strong>rabbb</strong>”</p></li>
<li><p>Add them together, we know rst[i][j]=3:  “<strong>rab</strong>  b <strong>b</strong>” and “<strong>ra</strong> b <strong>bb</strong>” and “<strong>rabbb</strong>”.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Finally we output rst[s.length()-1][t.length()-1].</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">numDistinct</span><span class="p">(</span><span class="n">String</span> <span class="n">s</span><span class="p">,</span> <span class="n">String</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="na">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span><span class="o">[][]</span> <span class="n">rst</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="p">()</span><span class="o">][</span><span class="n">t</span><span class="p">.</span><span class="na">length</span><span class="p">()</span><span class="o">]</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">rst</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">rst</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// System.out.println(&quot;i: &quot;+ 0 + &quot; j: &quot;+0 + &quot; rst: &quot; + rst[0][0]);</span>

    <span class="c1">// for j==0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]+</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// System.out.println(&quot;i: &quot;+i + &quot; j: &quot;+0 + &quot; rst: &quot; + rst[i][0]);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">t</span><span class="p">.</span><span class="na">length</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rst</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">rst</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">rst</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// System.out.println(&quot;i: &quot;+j + &quot; j: &quot;+j + &quot; rst: &quot; + rst[j][j]);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// if (rst[i][j-1] == rst[i-1][j-1] + 1) {</span>
                <span class="c1">//     rst[i][j] = rst[i][j-1];</span>
                <span class="c1">// } else {</span>
                <span class="c1">//     rst[i][j] = rst[i][j-1] + rst[i-1][j];</span>
                <span class="c1">// }</span>
                <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// System.out.println(&quot;i: &quot;+i + &quot; j: &quot;+j + &quot; rst: &quot; + rst[i][j]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">rst</span><span class="o">[</span><span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">t</span><span class="p">.</span><span class="na">length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="binary-tree-maximum-path-sum">
<h2><a class="toc-backref" href="#id5">124. Binary Tree Maximum Path Sum</a><a class="headerlink" href="#binary-tree-maximum-path-sum" title="Permalink to this headline">¶</a></h2>
<p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p>
<p>The path sum of a path is the sum of the node’s values in the path.</p>
<p>Given the root of a binary tree, return the maximum path sum of any path.</p>
<p><strong>Approach</strong></p>
<ul>
<li><p>Given a node A, we need to calculate the path sum assuming A is the root node.</p></li>
<li><p>There are four possible cases (since node values can be negative):</p>
<blockquote>
<div><ul class="simple">
<li><p>A + pathSum of the left child tree</p></li>
<li><p>A + pathSum of the right child tree</p></li>
<li><p>Only A</p></li>
<li><p>A + pathSum of both children trees</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Observe that for A’s parent, only the first three cases can be considered (these are the sums that can be used by the parent). Because if a path includes A and both of it’s children, this path cannot be added to the path that goes through A’s parent (this is the sum that cannot be used by the parent).</p></li>
<li><p>Therefore for each node, we calculate two sums: one is the path sum of A as the root, which cannot be used by the parent; the other one is the max of the first three cases, which can be used by the A’s parent.</p></li>
<li><p>We can keep a global variable that keep record of the running maximum.</p></li>
<li><p>Then when doing tree traversal, return the sum that can be used by the parent for each node. Meanwhile compare the results of the four cases to the global maximum.</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">rst</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MIN_VALUE</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">leftSum</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">rightSum</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>

        <span class="c1">// parent can use</span>
        <span class="kt">int</span> <span class="n">sumForParent</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">leftSum</span> <span class="o">+</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">,</span> <span class="n">rightSum</span><span class="o">+</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">),</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>

        <span class="c1">// parent cannot use</span>
        <span class="kt">int</span> <span class="n">sumNotForParent</span> <span class="o">=</span> <span class="n">leftSum</span> <span class="o">+</span> <span class="n">rightSum</span> <span class="o">+</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>

        <span class="n">rst</span> <span class="o">=</span>  <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">sumForParent</span><span class="p">,</span> <span class="n">rst</span><span class="p">),</span> <span class="n">sumNotForParent</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">sumForParent</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="dungeon-game">
<h2><a class="toc-backref" href="#id6">174. Dungeon Game</a><a class="headerlink" href="#dungeon-game" title="Permalink to this headline">¶</a></h2>
<p>The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight’s health (represented by positive integers).</p>
<p>To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p>Return the knight’s minimum initial health so that he can rescue the princess.</p>
<p>Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>
<p><strong>Approach</strong></p>
<ul class="simple">
<li><p>Keep a 2D array rst where rst[i][j] means the min health it required to enter dungeon[i][j].</p></li>
<li><p>Suppose we are going from room A to room B. The minimum health required to enter room B is t and suppose dungeon[A] is c. Then the health requirement of room A is h + c = t. If c is larger than t, e.g. if we can gain 30 health at room A and B requires only 10 health, the health requirement of A is then 1. So h = max(1, t-c).</p></li>
<li><p>For any room, we can either go right or go down, choose whichever is less or whichever is go-able.</p></li>
<li><p>Then we just traverse from the bottom-right up till top-left then output rst[0][0];</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">calculateMinimumHP</span><span class="p">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">dungeon</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">dungeon</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">rst</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>

    <span class="c1">//System.out.println(&quot;i: &quot;+(m-1)+&quot; j: &quot;+(n-1)+&quot; rst: &quot;+rst[m-1][n-1]);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// bottom-right</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">getH</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dungeon</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// can&#39;t go right</span>
                <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">getH</span><span class="p">(</span><span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">,</span> <span class="n">dungeon</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// can&#39;t go down</span>
                <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">getH</span><span class="p">(</span><span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="n">dungeon</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">//rst[i][j] = Math.min(getH(rst[i+1][j], dungeon[i+1][j]), getH(rst[i][j+1], dungeon[i][j+1]));</span>
                <span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">getH</span><span class="p">(</span><span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">,</span> <span class="n">dungeon</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">),</span> <span class="n">getH</span><span class="p">(</span><span class="n">rst</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="n">dungeon</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="c1">//System.out.println(&quot;i: &quot;+i+&quot; j: &quot;+j+&quot; rst: &quot;+rst[i][j]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">rst</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">getH</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="hash_table.html" title="Hash"
             >next</a> |</li>
        <li class="right" >
          <a href="disjoint_set.html" title="Disjoint Set"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Notebook  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Dynamic Programming</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Yixuan Ni.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
    

  </body>
</html>