

<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Tree &#8212; Notebook  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/yeen.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Retirement Plans" href="../Finance/retirement_plan.html" />
    <link rel="prev" title="Stack" href="stack.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../Finance/retirement_plan.html" title="Retirement Plans"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="stack.html" title="Stack"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Notebook  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tree</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tree</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tree-traversals-inorder-preorder-and-postorder">Tree Traversals (Inorder, Preorder and Postorder)</a><ul>
<li><a class="reference internal" href="#letter-case-permutation">784. Letter Case Permutation</a></li>
<li><a class="reference internal" href="#find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree">1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a></li>
<li><a class="reference internal" href="#sum-of-nodes-with-even-valued-grandparent">1315. Sum of Nodes with Even-Valued Grandparent</a></li>
<li><a class="reference internal" href="#recover-binary-search-tree">99. Recover Binary Search Tree</a><ul>
<li><a class="reference internal" href="#first-approach-in-order-traversal">First Approach - In Order Traversal</a></li>
<li><a class="reference internal" href="#second-approach-in-order-traversal-in-place-swap">Second Approach - In Order Traversal In Place Swap</a></li>
</ul>
</li>
<li><a class="reference internal" href="#binary-tree-right-side-view">199. Binary Tree Right Side View</a></li>
<li><a class="reference internal" href="#house-robber-iii">337. House Robber III</a></li>
<li><a class="reference internal" href="#binary-tree-level-order-traversal">102. Binary Tree Level Order Traversal</a></li>
<li><a class="reference internal" href="#binary-tree-level-order-traversal-ii">107. Binary Tree Level Order Traversal II</a></li>
<li><a class="reference internal" href="#average-of-levels-in-binary-tree">637. Average of Levels in Binary Tree</a></li>
<li><a class="reference internal" href="#n-ary-tree-level-order-traversal">429. N-ary Tree Level Order Traversal</a></li>
<li><a class="reference internal" href="#find-largest-value-in-each-tree-row">515. Find Largest Value in Each Tree Row</a></li>
<li><a class="reference internal" href="#populating-next-right-pointers-in-each-node">116. Populating Next Right Pointers in Each Node</a></li>
<li><a class="reference internal" href="#populating-next-right-pointers-in-each-node-ii">117. Populating Next Right Pointers in Each Node II</a></li>
<li><a class="reference internal" href="#invert-binary-tree">226. Invert Binary Tree</a></li>
<li><a class="reference internal" href="#symmetric-tree">101. Symmetric Tree</a></li>
<li><a class="reference internal" href="#minimum-depth-of-binary-tree">111. Minimum Depth of Binary Tree</a></li>
<li><a class="reference internal" href="#balanced-binary-tree">110. Balanced Binary Tree</a></li>
<li><a class="reference internal" href="#count-good-nodes-in-binary-tree">1448. Count Good Nodes in Binary Tree</a></li>
<li><a class="reference internal" href="#binary-tree-paths">257. Binary Tree Paths</a></li>
<li><a class="reference internal" href="#sum-of-left-leaves">404. Sum of Left Leaves</a></li>
<li><a class="reference internal" href="#find-bottom-left-tree-value">513. Find Bottom Left Tree Value</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="stack.html"
                        title="previous chapter">Stack</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../Finance/retirement_plan.html"
                        title="next chapter">Retirement Plans</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/Algorithm/tree.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="tree">
<h1><a class="toc-backref" href="#id1">Tree</a><a class="headerlink" href="#tree" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#tree" id="id1">Tree</a></p>
<ul>
<li><p><a class="reference internal" href="#overview" id="id2">Overview</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tree-traversals-inorder-preorder-and-postorder" id="id3">Tree Traversals (Inorder, Preorder and Postorder)</a></p>
<ul>
<li><p><a class="reference internal" href="#letter-case-permutation" id="id4">784. Letter Case Permutation</a></p></li>
<li><p><a class="reference internal" href="#find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree" id="id5">1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a></p></li>
<li><p><a class="reference internal" href="#sum-of-nodes-with-even-valued-grandparent" id="id6">1315. Sum of Nodes with Even-Valued Grandparent</a></p></li>
<li><p><a class="reference internal" href="#recover-binary-search-tree" id="id7">99. Recover Binary Search Tree</a></p></li>
<li><p><a class="reference internal" href="#binary-tree-right-side-view" id="id8">199. Binary Tree Right Side View</a></p></li>
<li><p><a class="reference internal" href="#house-robber-iii" id="id9">337. House Robber III</a></p></li>
<li><p><a class="reference internal" href="#binary-tree-level-order-traversal" id="id10">102. Binary Tree Level Order Traversal</a></p></li>
<li><p><a class="reference internal" href="#binary-tree-level-order-traversal-ii" id="id11">107. Binary Tree Level Order Traversal II</a></p></li>
<li><p><a class="reference internal" href="#average-of-levels-in-binary-tree" id="id12">637. Average of Levels in Binary Tree</a></p></li>
<li><p><a class="reference internal" href="#n-ary-tree-level-order-traversal" id="id13">429. N-ary Tree Level Order Traversal</a></p></li>
<li><p><a class="reference internal" href="#find-largest-value-in-each-tree-row" id="id14">515. Find Largest Value in Each Tree Row</a></p></li>
<li><p><a class="reference internal" href="#populating-next-right-pointers-in-each-node" id="id15">116. Populating Next Right Pointers in Each Node</a></p></li>
<li><p><a class="reference internal" href="#populating-next-right-pointers-in-each-node-ii" id="id16">117. Populating Next Right Pointers in Each Node II</a></p></li>
<li><p><a class="reference internal" href="#invert-binary-tree" id="id17">226. Invert Binary Tree</a></p></li>
<li><p><a class="reference internal" href="#symmetric-tree" id="id18">101. Symmetric Tree</a></p></li>
<li><p><a class="reference internal" href="#minimum-depth-of-binary-tree" id="id19">111. Minimum Depth of Binary Tree</a></p></li>
<li><p><a class="reference internal" href="#balanced-binary-tree" id="id20">110. Balanced Binary Tree</a></p></li>
<li><p><a class="reference internal" href="#count-good-nodes-in-binary-tree" id="id21">1448. Count Good Nodes in Binary Tree</a></p></li>
<li><p><a class="reference internal" href="#binary-tree-paths" id="id22">257. Binary Tree Paths</a></p></li>
<li><p><a class="reference internal" href="#sum-of-left-leaves" id="id23">404. Sum of Left Leaves</a></p></li>
<li><p><a class="reference internal" href="#find-bottom-left-tree-value" id="id24">513. Find Bottom Left Tree Value</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="overview">
<h2><a class="toc-backref" href="#id2">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Definition for a binary tree node.</span>
<span class="cm"> * public class TreeNode {</span>
<span class="cm"> *     int val;</span>
<span class="cm"> *     TreeNode left;</span>
<span class="cm"> *     TreeNode right;</span>
<span class="cm"> *     TreeNode() {}</span>
<span class="cm"> *     TreeNode(int val) { this.val = val; }</span>
<span class="cm"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span>
<span class="cm"> *         this.val = val;</span>
<span class="cm"> *         this.left = left;</span>
<span class="cm"> *         this.right = right;</span>
<span class="cm"> *     }</span>
<span class="cm"> * }</span>
<span class="cm"> */</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Template</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">int</span> <span class="nf">getResult</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Set nextXX for the left iteration and right iteration according to the question</span>

    <span class="c1">// Change rst when constraints are met</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">constraints_are_met</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rst</span> <span class="o">+=</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">rst</span> <span class="o">=</span> <span class="n">getResult</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">nextXX</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
    <span class="n">rst</span> <span class="o">=</span> <span class="n">getResult</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">nextXX</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="tree-traversals-inorder-preorder-and-postorder">
<h1><a class="toc-backref" href="#id3">Tree Traversals (Inorder, Preorder and Postorder)</a><a class="headerlink" href="#tree-traversals-inorder-preorder-and-postorder" title="Permalink to this headline">¶</a></h1>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/tree_traversal.png"><img alt="../_images/tree_traversal.png" src="../_images/tree_traversal.png" style="width: 259.0px; height: 156.0px;" /></a>
</figure>
<p>Depth First Traversals:</p>
<ol class="loweralpha simple">
<li><p>Inorder (Left, Root, Right) : 4 2 5 1 3</p></li>
<li><p>Preorder (Root, Left, Right) : 1 2 4 5 3</p></li>
<li><p>Postorder (Left, Right, Root) : 4 5 2 3 1</p></li>
</ol>
<p>Breadth-First or Level Order Traversal: 1 2 3 4 5</p>
<section id="letter-case-permutation">
<h2><a class="toc-backref" href="#id4">784. Letter Case Permutation</a><a class="headerlink" href="#letter-case-permutation" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, return the sum of values of its deepest leaves.</p>
<div class="topic">
<p class="topic-title">Examples</p>
<p>Input:</p>
<p>1</p>
<p>2, 3</p>
<p>4, 5, null, 6</p>
<p>7, null, null, null, null, null, null, 8</p>
<p>Output: 7 + 8 = 15</p>
</div>
<p>Approach: first traverse the tree to get the maximum depth. Then traverse again, if the depth is equal to the
maximum depth, return that value.</p>
<p>Note:</p>
<ul class="simple">
<li><p>Depth increment should be done after the <code class="docutils literal notranslate"><span class="pre">root</span> <span class="pre">==</span> <span class="pre">null</span></code> check. Otherwise depth will 1 more.</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">currentDepth</span> <span class="pre">==</span> <span class="pre">maxDepth</span></code>, just return the current root value.</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Definition for a binary tree node.</span>
<span class="cm"> * public class TreeNode {</span>
<span class="cm"> *     int val;</span>
<span class="cm"> *     TreeNode left;</span>
<span class="cm"> *     TreeNode right;</span>
<span class="cm"> *     TreeNode() {}</span>
<span class="cm"> *     TreeNode(int val) { this.val = val; }</span>
<span class="cm"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span>
<span class="cm"> *         this.val = val;</span>
<span class="cm"> *         this.left = left;</span>
<span class="cm"> *         this.right = right;</span>
<span class="cm"> *     }</span>
<span class="cm"> * }</span>
<span class="cm"> */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">deepestLeavesSum</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">maxDepth</span> <span class="o">=</span> <span class="n">getMaxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;maxD: &quot;</span><span class="o">+</span><span class="n">maxDepth</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">getLeavesSum</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxDepth</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getMaxDepth</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;root: &quot;</span><span class="o">+</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="o">+</span> <span class="s">&quot; currentD: &quot;</span><span class="o">+</span> <span class="n">depth</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">getMaxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">depth</span><span class="p">),</span> <span class="n">getMaxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">depth</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getLeavesSum</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">currentDepth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">currentDepth</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;root: &quot;</span><span class="o">+</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="o">+</span> <span class="s">&quot; currentD: &quot;</span><span class="o">+</span><span class="n">currentDepth</span><span class="p">);</span>


        <span class="k">if</span> <span class="p">(</span><span class="n">currentDepth</span> <span class="o">==</span> <span class="n">maxDepth</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">getLeavesSum</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">currentDepth</span><span class="p">,</span> <span class="n">maxDepth</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">getLeavesSum</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">currentDepth</span><span class="p">,</span> <span class="n">maxDepth</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Running result</p>
<p>root: 1 currentD: 1
root: 2 currentD: 2
root: 4 currentD: 3
root: 7 currentD: 4
root: 5 currentD: 3
root: 3 currentD: 2
root: 6 currentD: 3
root: 8 currentD: 4
maxD: 4
root: 1 currentD: 1
root: 2 currentD: 2
root: 4 currentD: 3
root: 7 currentD: 4
root: 5 currentD: 3
root: 3 currentD: 2
root: 6 currentD: 3
root: 8 currentD: 4</p>
</div>
</section>
<section id="find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree">
<h2><a class="toc-backref" href="#id5">1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a><a class="headerlink" href="#find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree" title="Permalink to this headline">¶</a></h2>
<p>Given two binary trees original and cloned and given a reference to a node target in the original tree.</p>
<p>The cloned tree is a copy of the original tree.</p>
<p>Return a reference to the same node in the cloned tree.</p>
<p>Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.</p>
<p>Follow up: Solve the problem if repeated values on the tree are allowed.</p>
<p>Constraints:</p>
<p>The number of nodes in the tree is in the range [1, 10^4].</p>
<p>The values of the nodes of the tree are unique.</p>
<p>target node is a node from the original tree and is not null.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Definition for a binary tree node.</span>
<span class="cm"> * public class TreeNode {</span>
<span class="cm"> *     int val;</span>
<span class="cm"> *     TreeNode left;</span>
<span class="cm"> *     TreeNode right;</span>
<span class="cm"> *     TreeNode(int x) { val = x; }</span>
<span class="cm"> * }</span>
<span class="cm"> */</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">TreeNode</span> <span class="nf">getTargetCopy</span><span class="p">(</span><span class="kd">final</span> <span class="n">TreeNode</span> <span class="n">original</span><span class="p">,</span> <span class="kd">final</span> <span class="n">TreeNode</span> <span class="n">cloned</span><span class="p">,</span> <span class="kd">final</span> <span class="n">TreeNode</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cloned</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cloned</span><span class="p">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="p">.</span><span class="na">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">cloned</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">getTargetCopy</span><span class="p">(</span><span class="n">original</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">cloned</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">getTargetCopy</span><span class="p">(</span><span class="n">original</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">cloned</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="sum-of-nodes-with-even-valued-grandparent">
<h2><a class="toc-backref" href="#id6">1315. Sum of Nodes with Even-Valued Grandparent</a><a class="headerlink" href="#sum-of-nodes-with-even-valued-grandparent" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/">https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/</a></p>
<p>Given a binary tree, return the sum of values of nodes with even-valued grandparent.  (A grandparent of a node is the parent of its parent, if it exists.)</p>
<p>If there are no nodes with an even-valued grandparent, return 0.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumEvenGrandparent</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">getResult</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getResult</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="kt">boolean</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">boolean</span> <span class="n">grandparent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// System.out.println(&quot;root: &quot; + root.val + &quot;, parent: &quot; + parent + &quot;, grandparent: &quot; + grandparent + &quot;, rst: &quot;+ rst);</span>

        <span class="kt">boolean</span> <span class="n">nextParent</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nextParent</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">boolean</span> <span class="n">nextGrandParent</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nextGrandParent</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Grandparent is even</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grandparent</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rst</span> <span class="o">+=</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">rst</span> <span class="o">=</span> <span class="n">getResult</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">nextParent</span><span class="p">,</span> <span class="n">nextGrandParent</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
        <span class="n">rst</span> <span class="o">=</span> <span class="n">getResult</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">nextParent</span><span class="p">,</span> <span class="n">nextGrandParent</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>


    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Running result</p>
<p>root: 6, parent: false, grandparent: false, rst: 0</p>
<p>root: 7, parent: true, grandparent: false, rst: 0</p>
<p>root: 2, parent: false, grandparent: true, rst: 0</p>
<p>root: 9, parent: true, grandparent: false, rst: 2</p>
<p>root: 7, parent: false, grandparent: true, rst: 2</p>
<p>root: 1, parent: false, grandparent: false, rst: 9</p>
<p>root: 4, parent: false, grandparent: false, rst: 9</p>
<p>root: 8, parent: true, grandparent: false, rst: 9</p>
<p>root: 1, parent: true, grandparent: true, rst: 9</p>
<p>root: 3, parent: true, grandparent: true, rst: 10</p>
<p>root: 5, parent: false, grandparent: true, rst: 13</p>
</div>
</section>
<section id="recover-binary-search-tree">
<h2><a class="toc-backref" href="#id7">99. Recover Binary Search Tree</a><a class="headerlink" href="#recover-binary-search-tree" title="Permalink to this headline">¶</a></h2>
<p>You are given the root of a binary search tree (BST), where exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.</p>
<p>Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
<section id="first-approach-in-order-traversal">
<h3>First Approach - In Order Traversal<a class="headerlink" href="#first-approach-in-order-traversal" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Do an in order traversal(iot) of the tree.</p></li>
<li><p>Find the two elements in the iot that are not in the right order.</p></li>
<li><p>Search the tree again and swap the values.</p></li>
</ol>
<div class="topic">
<p class="topic-title">InOrderTraversal</p>
<p>After traversing, the sequence is in ascending order.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">inOrderTraversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rst</span> <span class="o">=</span> <span class="p">(</span><span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">));</span>
    <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>
    <span class="n">rst</span><span class="p">.</span><span class="na">addAll</span><span class="p">(</span><span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">inOrderTraversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
    <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>
    <span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">recoverTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">iot</span> <span class="o">=</span> <span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="n">Integer</span> <span class="n">first</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="n">Integer</span> <span class="n">second</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

        <span class="n">Integer</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">iot</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">Integer</span> <span class="n">current</span> <span class="p">:</span> <span class="n">iot</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&gt;</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">first</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">second</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//System.out.println(&quot;first: &quot;+first + &quot; second: &quot;+second);</span>

        <span class="n">swap</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>



    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// first &gt; second</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">swap</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">first</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//System.out.println(&quot;Swap to &quot; + second + &quot;: &quot; + root.val);</span>
            <span class="n">root</span><span class="p">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">second</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">second</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//System.out.println(&quot;Swap to &quot; + first + &quot;: &quot; + root.val);</span>
            <span class="n">root</span><span class="p">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">swap</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="second-approach-in-order-traversal-in-place-swap">
<h3>Second Approach - In Order Traversal In Place Swap<a class="headerlink" href="#second-approach-in-order-traversal-in-place-swap" title="Permalink to this headline">¶</a></h3>
<p>Same idea as the first approach, just do the swap while doing in order traversal.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="n">TreeNode</span> <span class="n">first</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="n">second</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">recoverTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

        <span class="c1">//System.out.println(&quot;fisrt: &quot;+first.val + &quot; second: &quot;+second.val);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">second</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>

            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">second</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>
            <span class="n">second</span><span class="p">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>
            <span class="n">first</span><span class="p">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">inOrderTraversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="p">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">second</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">prev</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

        <span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="binary-tree-right-side-view">
<h2><a class="toc-backref" href="#id8">199. Binary Tree Right Side View</a><a class="headerlink" href="#binary-tree-right-side-view" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>(This question is quite easy)</p>
<p>Approach: Keep a depth when traverse the tree. Keep an array list rst to store the final result. The index of the array list corresponds to the depth. For example, rst.get(5) is the right most TreeNode at depth 5. We do a right first traverse. Each time we reach a depth k for the first time (determined by rst.size()&lt;k), we know that it is the right most TreeNode.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverseTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverseTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rst</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">traverseTree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">traverseTree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="house-robber-iii">
<h2><a class="toc-backref" href="#id9">337. House Robber III</a><a class="headerlink" href="#house-robber-iii" title="Permalink to this headline">¶</a></h2>
<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.</p>
<p>Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.</p>
<p>Approach: For each node, we either choose it or not choose it. If we choose it, we cannot rob the left nor the right. If we don’t choose it, we can rob or not rub the left, or rob or not rub the right (4 cases). So the helper function returns a pair of values for each node, one is the gain by choosing it, one is gain by not choosing it. Then at the end we compare the gain for the root.</p>
<p>Tip: using array instead of ArrayList will be much faster (54.95% -&gt; 100%) and saves space.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rst</span> <span class="o">=</span> <span class="n">_rob</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">rst</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rst</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">_rob</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 0 = choose, 1 = not choose</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rstLeft</span> <span class="o">=</span> <span class="n">_rob</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">);</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rstRight</span> <span class="o">=</span> <span class="n">_rob</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">robLeft</span> <span class="o">=</span> <span class="n">rstLeft</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">robRight</span> <span class="o">=</span> <span class="n">rstRight</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">robLeftNo</span> <span class="o">=</span> <span class="n">rstLeft</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">robRightNo</span> <span class="o">=</span> <span class="n">rstRight</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        <span class="c1">// If choose root, do not choose left or right</span>
        <span class="n">rst</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">robLeftNo</span> <span class="o">+</span> <span class="n">robRightNo</span><span class="p">);</span>

        <span class="c1">// If don&#39;t choose root, either choose/not left or choose/not right</span>
        <span class="n">rst</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">robLeft</span> <span class="o">+</span> <span class="n">robRight</span><span class="p">,</span> <span class="n">robLeft</span> <span class="o">+</span> <span class="n">robRightNo</span><span class="p">),</span> <span class="n">robLeftNo</span> <span class="o">+</span> <span class="n">robRight</span><span class="p">),</span> <span class="n">robLeftNo</span> <span class="o">+</span> <span class="n">robRightNo</span><span class="p">));</span>

        <span class="c1">//System.out.println(&quot;root: &quot; + root.val + &quot; choose: &quot;+ rst.get(0) + &quot; not choose: &quot; + rst.get(1));</span>
        <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>

    <span class="p">}</span>
</pre></div>
</div>
</section>
<section id="binary-tree-level-order-traversal">
<h2><a class="toc-backref" href="#id10">102. Binary Tree Level Order Traversal</a><a class="headerlink" href="#binary-tree-level-order-traversal" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [3,9,20,null,null,15,7]</p>
<p>Output: [[3],[9,20],[15,7]]</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [1]</p>
<p>Output: [[1]]</p>
</div>
<div class="topic">
<p class="topic-title">Example 3</p>
<p>Input: root = []</p>
<p>Output: []</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [0, 2000].</p>
<p>-1000 &lt;= Node.val &lt;= 1000</p>
</div>
<p><strong>Note:</strong> This is BFS. See 107. Binary Tree Level Order Traversal II for DFS solution which will be faster than BFS.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">rst</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="n">rst</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">level</span><span class="p">).</span><span class="na">add</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="binary-tree-level-order-traversal-ii">
<h2><a class="toc-backref" href="#id11">107. Binary Tree Level Order Traversal II</a><a class="headerlink" href="#binary-tree-level-order-traversal-ii" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [3,9,20,null,null,15,7]</p>
<p>Output: [[15,7],[9,20],[3]]</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [1]</p>
<p>Output: [[1]]</p>
</div>
<div class="topic">
<p class="topic-title">Example 3</p>
<p>Input: root = []</p>
<p>Output: []</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [0, 2000].</p>
<p>-1000 &lt;= Node.val &lt;= 1000</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrderBottom</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">Collections</span><span class="p">.</span><span class="na">reverse</span><span class="p">(</span><span class="n">rst</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">rst</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">rst</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">depth</span><span class="p">).</span><span class="na">add</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="average-of-levels-in-binary-tree">
<h2><a class="toc-backref" href="#id12">637. Average of Levels in Binary Tree</a><a class="headerlink" href="#average-of-levels-in-binary-tree" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [3,9,20,null,15,7]</p>
<p>Output: [3.00000,14.50000,11.00000]</p>
<p>Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.</p>
<p>Hence return [3, 14.5, 11].</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [3,9,20,15,7]</p>
<p>Output: [3.00000,14.50000,11.00000]</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [1, 104].</p>
<p>-231 &lt;= Node.val &lt;= 231 - 1</p>
</div>
<p><strong>Note</strong>: use double to avoid overflow.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="nf">averageOfLevels</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">avgs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">nNodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">avgs</span><span class="p">,</span> <span class="n">nNodes</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">avgs</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">avgs</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">nNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">avgs</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">avgs</span><span class="p">.</span><span class="na">add</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span> <span class="c1">// we get to a new level</span>
        <span class="n">nNodes</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nNodes</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">avgs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
        <span class="n">avgs</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">nNodes</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">avgs</span><span class="p">,</span> <span class="n">nNodes</span><span class="p">);</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">avgs</span><span class="p">,</span> <span class="n">nNodes</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="n-ary-tree-level-order-traversal">
<h2><a class="toc-backref" href="#id13">429. N-ary Tree Level Order Traversal</a><a class="headerlink" href="#n-ary-tree-level-order-traversal" title="Permalink to this headline">¶</a></h2>
<p>Given an n-ary tree, return the level order traversal of its nodes’ values.</p>
<p>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [1,null,3,2,4,null,5,6]</p>
<p>Output: [[1],[3,2,4],[5,6]]</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</p>
<p>Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The height of the n-ary tree is less than or equal to 1000</p>
<p>The total number of nodes is between [0, 104]</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">// Definition for a Node.</span>
<span class="cm">class Node {</span>
<span class="cm">    public int val;</span>
<span class="cm">    public List&lt;Node&gt; children;</span>

<span class="cm">    public Node() {}</span>

<span class="cm">    public Node(int _val) {</span>
<span class="cm">        val = _val;</span>
<span class="cm">    }</span>

<span class="cm">    public Node(int _val, List&lt;Node&gt; _children) {</span>
<span class="cm">        val = _val;</span>
<span class="cm">        children = _children;</span>
<span class="cm">    }</span>
<span class="cm">};</span>
<span class="cm">*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">Node</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">Node</span> <span class="n">root</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">rst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">child</span> <span class="p">:</span> <span class="n">root</span><span class="p">.</span><span class="na">children</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">rst</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="n">rst</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">depth</span><span class="p">).</span><span class="na">add</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="find-largest-value-in-each-tree-row">
<h2><a class="toc-backref" href="#id14">515. Find Largest Value in Each Tree Row</a><a class="headerlink" href="#find-largest-value-in-each-tree-row" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [1,3,2,5,3,null,9]</p>
<p>Output: [1,3,9]</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [1,2,3]</p>
<p>Output: [1,3]</p>
</div>
<div class="topic">
<p class="topic-title">Example 3</p>
<p>Input: root = [1]</p>
<p>Output: [1]</p>
</div>
<div class="topic">
<p class="topic-title">Example 4</p>
<p>Input: root = [1,null,2]</p>
<p>Output: [1,2]</p>
</div>
<div class="topic">
<p class="topic-title">Example 5</p>
<p>Input: root = []</p>
<p>Output: []</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree will be in the range [0, 104].</p>
<p>-231 &lt;= Node.val &lt;= 231 - 1</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">largestValues</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">maxes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">maxes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">maxes</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">maxes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">maxes</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">maxes</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxes</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Integer</span><span class="p">.</span><span class="na">MIN_VALUE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">maxes</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">maxes</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">depth</span><span class="p">),</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">));</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">maxes</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="populating-next-right-pointers-in-each-node">
<h2><a class="toc-backref" href="#id15">116. Populating Next Right Pointers in Each Node</a><a class="headerlink" href="#populating-next-right-pointers-in-each-node" title="Permalink to this headline">¶</a></h2>
<p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [1,2,3,4,5,6,7]</p>
<p>Output: [1,#,2,3,#,4,5,6,7,#]</p>
<p>Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with ‘#’ signifying the end of each level.</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = []</p>
<p>Output: []</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [0, 212 - 1].</p>
<p>-1000 &lt;= Node.val &lt;= 1000</p>
</div>
<div class="topic">
<p class="topic-title">Follow-up</p>
<p>You may only use constant extra space.</p>
<p>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</p>
</div>
<p><strong>Approach</strong>: Given a current root node:</p>
<ul class="simple">
<li><p>For its left child, the pointer should points to the right child of the root node.</p></li>
<li><p>For its right child, the pointer should points to either null or the left child of root’s next node.</p></li>
<li><p>For example, given</p></li>
</ul>
<p>1</p>
<p>2 3</p>
<p>4 5 6 7</p>
<p>Suppose current node is 2, its left child is 4, which should point to its right child (5). Its right child is 5, which should point to the left child of 5’s next node(3)’s child (6).</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">Node</span> <span class="nf">connect</span><span class="p">(</span><span class="n">Node</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">Node</span> <span class="n">root</span><span class="p">,</span> <span class="n">Node</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">root</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="na">left</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="populating-next-right-pointers-in-each-node-ii">
<h2><a class="toc-backref" href="#id16">117. Populating Next Right Pointers in Each Node II</a><a class="headerlink" href="#populating-next-right-pointers-in-each-node-ii" title="Permalink to this headline">¶</a></h2>
<p>Given a binary tree</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [1,2,3,4,5,null,7]</p>
<p>Output: [1,#,2,3,#,4,5,7,#]</p>
<p>Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with ‘#’ signifying the end of each level.</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = []</p>
<p>Output: []</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [0, 6000].</p>
<p>-100 &lt;= Node.val &lt;= 100</p>
</div>
<div class="topic">
<p class="topic-title">Follow-up</p>
<p>You may only use constant extra space.</p>
<p>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">Node</span> <span class="nf">connect</span><span class="p">(</span><span class="n">Node</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pointers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">pointers</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">Node</span> <span class="n">root</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pointers</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pointers</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pointers</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">root</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">root</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pointers</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
        <span class="n">pointers</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">pointers</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">pointers</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="invert-binary-tree">
<h2><a class="toc-backref" href="#id17">226. Invert Binary Tree</a><a class="headerlink" href="#invert-binary-tree" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, invert the tree, and return its root.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [4,2,7,1,3,6,9]</p>
<p>Output: [4,7,2,9,6,3,1]</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [2,1,3]</p>
<p>Output: [2,3,1]</p>
</div>
<div class="topic">
<p class="topic-title">Example 3</p>
<p>Input: root = []</p>
<p>Output: []</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [0, 100].</p>
<p>-100 &lt;= Node.val &lt;= 100</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">);</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>

    <span class="n">TreeNode</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">;</span>
    <span class="n">root</span><span class="p">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">;</span>
    <span class="n">root</span><span class="p">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="symmetric-tree">
<h2><a class="toc-backref" href="#id18">101. Symmetric Tree</a><a class="headerlink" href="#symmetric-tree" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [1,2,2,3,4,4,3]</p>
<p>Output: true</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [1,2,2,null,3,null,3]</p>
<p>Output: false</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [1, 1000].</p>
<p>-100 &lt;= Node.val &lt;= 100</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">compare</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">compare</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span>
       <span class="n">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">right</span><span class="p">.</span><span class="na">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">compare</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">right</span><span class="p">.</span><span class="na">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">right</span><span class="p">.</span><span class="na">left</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="minimum-depth-of-binary-tree">
<h2><a class="toc-backref" href="#id19">111. Minimum Depth of Binary Tree</a><a class="headerlink" href="#minimum-depth-of-binary-tree" title="Permalink to this headline">¶</a></h2>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<div class="topic">
<p class="topic-title">Example 1:</p>
<p>Input: root = [3,9,20,null,null,15,7]</p>
<p>Output: 2</p>
</div>
<div class="topic">
<p class="topic-title">Example 2:</p>
<p>Input: root = [2,null,3,null,4,null,5,null,6]</p>
<p>Output: 5</p>
</div>
<div class="topic">
<p class="topic-title">Constraints:</p>
<p>The number of nodes in the tree is in the range [0, 105].</p>
<p>-1000 &lt;= Node.val &lt;= 1000</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">minDepth</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="na">minDepth</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="k">this</span><span class="p">.</span><span class="na">minDepth</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="p">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="na">minDepth</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="na">minDepth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="balanced-binary-tree">
<h2><a class="toc-backref" href="#id20">110. Balanced Binary Tree</a><a class="headerlink" href="#balanced-binary-tree" title="Permalink to this headline">¶</a></h2>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<p>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [3,9,20,null,null,15,7]</p>
<p>Output: true</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [1,2,2,3,3,null,null,4,4]</p>
<p>Output: false</p>
</div>
<div class="topic">
<p class="topic-title">Example 3</p>
<p>Input: root = []</p>
<p>Output: true</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [0, 5000].</p>
<p>-104 &lt;= Node.val &lt;= 104</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">getDepth</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="n">getDepth</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">leftDepth</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="n">getDepth</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rightDepth</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">abs</span><span class="p">(</span><span class="n">leftDepth</span> <span class="o">-</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="count-good-nodes-in-binary-tree">
<h2><a class="toc-backref" href="#id21">1448. Count Good Nodes in Binary Tree</a><a class="headerlink" href="#count-good-nodes-in-binary-tree" title="Permalink to this headline">¶</a></h2>
<p>Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.</p>
<p>Return the number of good nodes in the binary tree.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [3,1,4,3,null,1,5]</p>
<p>Output: 4</p>
<p>Explanation: Nodes in blue are good.</p>
<p>Root Node (3) is always a good node.</p>
<p>Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.</p>
<p>Node 5 -&gt; (3,4,5) is the maximum value in the path</p>
<p>Node 3 -&gt; (3,1,3) is the maximum value in the path.</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [3,3,null,4,2]</p>
<p>Output: 3</p>
<p>Explanation: Node 2 -&gt; (3, 3, 2) is not good, because “3” is higher than it.</p>
</div>
<div class="topic">
<p class="topic-title">Example 3</p>
<p>Input: root = [1]</p>
<p>Output: 1</p>
<p>Explanation: Root is considered as good.</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the binary tree is in the range [1, 10^5].</p>
<p>Each node’s value is between [-10^4, 10^4].</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">goodNodes</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MIN_VALUE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">max</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">max</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>

    <span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">)</span><span class="o">?</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="binary-tree-paths">
<h2><a class="toc-backref" href="#id22">257. Binary Tree Paths</a><a class="headerlink" href="#binary-tree-paths" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, return all root-to-leaf paths in any order.</p>
<p>A leaf is a node with no children.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [1,2,3,null,5]</p>
<p>Output: [“1-&gt;2-&gt;5”,”1-&gt;3”]</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [1]</p>
<p>Output: [“1”]</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [1, 100].</p>
<p>-100 &lt;= Node.val &lt;= 100</p>
</div>
<p><strong>Approach</strong> use backtracking</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">rst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(),</span> <span class="n">rst</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">temp</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">temp</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="p">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">.</span><span class="na">join</span><span class="p">(</span><span class="s">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
        <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
        <span class="n">temp</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
        <span class="n">temp</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="sum-of-left-leaves">
<h2><a class="toc-backref" href="#id23">404. Sum of Left Leaves</a><a class="headerlink" href="#sum-of-left-leaves" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, return the sum of all left leaves.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [3,9,20,null,null,15,7]</p>
<p>Output: 24</p>
<p>Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [1]</p>
<p>Output: 0</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [1, 1000].</p>
<p>-1000 &lt;= Node.val &lt;= 1000</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="p">,</span> <span class="kt">boolean</span> <span class="n">isLeft</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="p">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">isLeft</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="o">+</span> <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="find-bottom-left-tree-value">
<h2><a class="toc-backref" href="#id24">513. Find Bottom Left Tree Value</a><a class="headerlink" href="#find-bottom-left-tree-value" title="Permalink to this headline">¶</a></h2>
<p>Given the root of a binary tree, return the leftmost value in the last row of the tree.</p>
<div class="topic">
<p class="topic-title">Example 1</p>
<p>Input: root = [2,1,3]</p>
<p>Output: 1</p>
</div>
<div class="topic">
<p class="topic-title">Example 2</p>
<p>Input: root = [1,2,3,4,null,5,6,null,null,7]</p>
<p>Output: 7</p>
</div>
<div class="topic">
<p class="topic-title">Constraints</p>
<p>The number of nodes in the tree is in the range [1, 104].</p>
<p>-231 &lt;= Node.val &lt;= 231 - 1</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rst</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rst</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">rst</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">rst</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rst</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rst</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxLeft</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">maxLeft</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="p">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">maxDepth</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">maxLeft</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>
            <span class="n">maxDepth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">left</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">right</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../Finance/retirement_plan.html" title="Retirement Plans"
             >next</a> |</li>
        <li class="right" >
          <a href="stack.html" title="Stack"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Notebook  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tree</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Yixuan Ni.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
    

  </body>
</html>